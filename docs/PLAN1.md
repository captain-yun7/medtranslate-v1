# ì™„ë²½í•œ ì„ íƒì…ë‹ˆë‹¤! ğŸ‘

Next.js (Frontend) + FastAPI (Backend)ê°€ **ê°€ì¥ í™•ì¥ì„± ìˆê³  í”„ë¡œí˜ì…”ë„í•œ êµ¬ì„±**ì…ë‹ˆë‹¤.

---

## 1. ìµœì¢… ì•„í‚¤í…ì²˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ì‚¬ìš©ì ë ˆì´ì–´                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ê³ ê° (ë³‘ì› ì‚¬ì´íŠ¸)              ìƒë‹´ì‚¬ (ê´€ë¦¬ ì½˜ì†”)        â”‚
â”‚  https://www.hospital-a.com     https://admin.medtranslate.co.kr â”‚
â”‚         â†“ (iframe)                      â†“                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Next.js Frontend (í”„ë¡ íŠ¸ì—”ë“œ)                â”‚
â”‚        https://chat.medtranslate.co.kr                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ - ê³ ê°ìš© ì±„íŒ… UI                              â”‚       â”‚
â”‚  â”‚ - ìƒë‹´ì‚¬ìš© ì½˜ì†” UI                            â”‚       â”‚
â”‚  â”‚ - ì–¸ì–´ ì„ íƒ, ë©”ì‹œì§€ ì…ë ¥                      â”‚       â”‚
â”‚  â”‚ - ì‹¤ì‹œê°„ ë©”ì‹œì§€ ë Œë”ë§                        â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
          WebSocket (Socket.io)  +  REST API
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              FastAPI Backend (ë°±ì—”ë“œ)                    â”‚
â”‚          https://api.medtranslate.co.kr                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ - Socket.io ì‹¤ì‹œê°„ í†µì‹  ì„œë²„                  â”‚       â”‚
â”‚  â”‚ - AI ë²ˆì—­ ì—”ì§„ (Claude/GPT/DeepL)            â”‚       â”‚
â”‚  â”‚ - ìƒë‹´ì‚¬ ë§¤ì¹­ ë¡œì§                            â”‚       â”‚
â”‚  â”‚ - ì±„íŒ… ì„¸ì…˜ ê´€ë¦¬                              â”‚       â”‚
â”‚  â”‚ - ì¸ì¦/ê¶Œí•œ ê´€ë¦¬                              â”‚       â”‚
â”‚  â”‚ - ë²ˆì—­ ìºì‹±                                   â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ë°ì´í„° ë ˆì´ì–´                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  PostgreSQL        Redis          S3/Storage            â”‚
â”‚  (ì±„íŒ… ë¡œê·¸)       (ìºì‹±)         (íŒŒì¼ ì²¨ë¶€)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. í”„ë¡œì íŠ¸ êµ¬ì¡°

```
medtranslate/
â”œâ”€â”€ frontend/                      # Next.js í”„ë¡ íŠ¸ì—”ë“œ
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ chat/
â”‚   â”‚   â”‚   â””â”€â”€ [roomId]/
â”‚   â”‚   â”‚       â””â”€â”€ page.tsx       # ê³ ê°ìš© ì±„íŒ…
â”‚   â”‚   â”œâ”€â”€ agent/
â”‚   â”‚   â”‚   â”œâ”€â”€ dashboard/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx       # ìƒë‹´ì‚¬ ëŒ€ì‹œë³´ë“œ
â”‚   â”‚   â”‚   â””â”€â”€ console/
â”‚   â”‚   â”‚       â””â”€â”€ [roomId]/
â”‚   â”‚   â”‚           â””â”€â”€ page.tsx   # ìƒë‹´ì‚¬ ì±„íŒ… ì½˜ì†”
â”‚   â”‚   â”œâ”€â”€ embed/
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx           # iframe ì„ë² ë“œìš©
â”‚   â”‚   â””â”€â”€ layout.tsx
â”‚   â”‚
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ Chat/
â”‚   â”‚   â”‚   â”œâ”€â”€ CustomerChat.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ AgentChat.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ MessageList.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ MessageInput.tsx
â”‚   â”‚   â”‚   â””â”€â”€ LanguageSelector.tsx
â”‚   â”‚   â””â”€â”€ ui/                    # shadcn/ui
â”‚   â”‚
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ socket.ts              # Socket.io í´ë¼ì´ì–¸íŠ¸
â”‚   â”‚   â”œâ”€â”€ api.ts                 # API í˜¸ì¶œ í•¨ìˆ˜
â”‚   â”‚   â””â”€â”€ utils.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”œâ”€â”€ useChat.ts
â”‚   â”‚   â””â”€â”€ useSocket.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ public/
â”‚   â”‚   â””â”€â”€ widget.js              # ì™¸ë¶€ ì„ë² ë“œ ìŠ¤í¬ë¦½íŠ¸
â”‚   â”‚
â”‚   â”œâ”€â”€ .env.local
â”‚   â”œâ”€â”€ next.config.js
â”‚   â”œâ”€â”€ package.json
â”‚   â””â”€â”€ tsconfig.json
â”‚
â”œâ”€â”€ backend/                       # FastAPI ë°±ì—”ë“œ
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ main.py                # FastAPI ì•± + Socket.io
â”‚   â”‚   â”œâ”€â”€ config.py              # ì„¤ì •
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â”œâ”€â”€ chat.py            # ì±„íŒ… REST API
â”‚   â”‚   â”‚   â”œâ”€â”€ agent.py           # ìƒë‹´ì‚¬ API
â”‚   â”‚   â”‚   â”œâ”€â”€ translation.py     # ë²ˆì—­ API
â”‚   â”‚   â”‚   â””â”€â”€ webhook.py         # ì›¹í›…
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ socket/
â”‚   â”‚   â”‚   â”œâ”€â”€ handlers.py        # Socket.io í•¸ë“¤ëŸ¬
â”‚   â”‚   â”‚   â””â”€â”€ events.py          # ì´ë²¤íŠ¸ ì •ì˜
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”œâ”€â”€ translation.py     # ë²ˆì—­ ì„œë¹„ìŠ¤
â”‚   â”‚   â”‚   â”œâ”€â”€ cache.py           # ìºì‹± ì„œë¹„ìŠ¤
â”‚   â”‚   â”‚   â”œâ”€â”€ session.py         # ì„¸ì…˜ ê´€ë¦¬
â”‚   â”‚   â”‚   â””â”€â”€ matching.py        # ìƒë‹´ì‚¬ ë§¤ì¹­
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”œâ”€â”€ database.py        # SQLAlchemy ëª¨ë¸
â”‚   â”‚   â”‚   â””â”€â”€ schemas.py         # Pydantic ìŠ¤í‚¤ë§ˆ
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ utils/
â”‚   â”‚       â”œâ”€â”€ auth.py            # ì¸ì¦
â”‚   â”‚       â””â”€â”€ helpers.py
â”‚   â”‚
â”‚   â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ alembic/                   # DB ë§ˆì´ê·¸ë ˆì´ì…˜
â”‚   â”œâ”€â”€ .env
â”‚   â”œâ”€â”€ requirements.txt
â”‚   â””â”€â”€ Dockerfile
â”‚
â”œâ”€â”€ shared/                        # ê³µí†µ íƒ€ì… ì •ì˜ (ì„ íƒ)
â”‚   â””â”€â”€ types.ts
â”‚
â”œâ”€â”€ infrastructure/                # ì¸í”„ë¼ ì½”ë“œ
â”‚   â”œâ”€â”€ docker-compose.yml
â”‚   â”œâ”€â”€ docker-compose.prod.yml
â”‚   â””â”€â”€ nginx/
â”‚       â””â”€â”€ nginx.conf
â”‚
â””â”€â”€ docs/                          # ë¬¸ì„œ
    â”œâ”€â”€ API.md
    â””â”€â”€ DEPLOYMENT.md
```

---

## 3. ë°±ì—”ë“œ (FastAPI) êµ¬í˜„

### A. main.py (í•µì‹¬ ì„œë²„)

```python
# backend/app/main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import socketio
import uvicorn

from app.config import settings
from app.api import chat, agent, translation
from app.socket.handlers import register_socket_handlers

# FastAPI ì•±
app = FastAPI(
    title="MedTranslate API",
    version="1.0.0",
    docs_url="/api/docs",
)

# CORS ì„¤ì •
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "https://chat.medtranslate.co.kr",
        "https://admin.medtranslate.co.kr",
        "http://localhost:3000",
        "http://localhost:3001",
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Socket.io ì„œë²„
sio = socketio.AsyncServer(
    async_mode='asgi',
    cors_allowed_origins=[
        "https://chat.medtranslate.co.kr",
        "https://admin.medtranslate.co.kr",
        "http://localhost:3000",
        "http://localhost:3001",
    ],
    logger=True,
    engineio_logger=True,
)

# Socket.io í•¸ë“¤ëŸ¬ ë“±ë¡
register_socket_handlers(sio)

# Socket.ioë¥¼ FastAPIì— ë§ˆìš´íŠ¸
socket_app = socketio.ASGIApp(sio, app)

# REST API ë¼ìš°í„°
app.include_router(chat.router, prefix="/api/chat", tags=["chat"])
app.include_router(agent.router, prefix="/api/agent", tags=["agent"])
app.include_router(translation.router, prefix="/api/translation", tags=["translation"])

@app.get("/")
async def root():
    return {"message": "MedTranslate API Server"}

@app.get("/health")
async def health_check():
    return {"status": "healthy"}

if __name__ == "__main__":
    uvicorn.run(
        "main:socket_app",
        host="0.0.0.0",
        port=8000,
        reload=True,
    )
```

### B. Socket.io í•¸ë“¤ëŸ¬

```python
# backend/app/socket/handlers.py
import socketio
from typing import Dict
from app.services.translation import TranslationService
from app.services.session import SessionManager
from app.models.database import save_message
import logging

logger = logging.getLogger(__name__)

# í™œì„± ì„¸ì…˜ ê´€ë¦¬
session_manager = SessionManager()
translation_service = TranslationService()

def register_socket_handlers(sio: socketio.AsyncServer):
    
    @sio.on('connect')
    async def connect(sid, environ):
        logger.info(f"Client connected: {sid}")
        await sio.emit('connected', {'sid': sid}, room=sid)
    
    @sio.on('disconnect')
    async def disconnect(sid):
        logger.info(f"Client disconnected: {sid}")
        # ì„¸ì…˜ ì •ë¦¬
        await session_manager.remove_connection(sid)
    
    @sio.on('join_room')
    async def join_room(sid, data):
        """
        ì±„íŒ…ë°© ì…ì¥
        data = {
            'room_id': 'room_123',
            'user_type': 'customer' | 'agent',
            'customer_language': 'vi',  # ê³ ê°ì¸ ê²½ìš°
            'agent_id': 'agent_001'     # ìƒë‹´ì‚¬ì¸ ê²½ìš°
        }
        """
        room_id = data['room_id']
        user_type = data['user_type']
        
        # Socket.io ë£¸ ì…ì¥
        await sio.enter_room(sid, room_id)
        
        # ì„¸ì…˜ì— ì—°ê²° ì •ë³´ ì €ì¥
        await session_manager.add_connection(
            room_id=room_id,
            sid=sid,
            user_type=user_type,
            language=data.get('customer_language'),
            agent_id=data.get('agent_id')
        )
        
        logger.info(f"{user_type} joined room {room_id}: {sid}")
        
        # ì…ì¥ í™•ì¸
        await sio.emit('joined_room', {
            'room_id': room_id,
            'user_type': user_type
        }, room=sid)
        
        # ìƒëŒ€ë°©ì´ ì´ë¯¸ ìˆìœ¼ë©´ ì•Œë¦¼
        session = await session_manager.get_session(room_id)
        if user_type == 'agent' and session.get('customer_sid'):
            await sio.emit('customer_online', {
                'language': session['customer_language']
            }, room=sid)
        elif user_type == 'customer' and session.get('agent_sid'):
            await sio.emit('agent_online', {}, room=sid)
    
    @sio.on('customer_message')
    async def handle_customer_message(sid, data):
        """
        ê³ ê° ë©”ì‹œì§€ ì²˜ë¦¬
        data = {
            'room_id': 'room_123',
            'message': 'Xin chÃ o',
            'timestamp': '2025-10-24T...'
        }
        """
        room_id = data['room_id']
        message = data['message']
        
        # ì„¸ì…˜ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        session = await session_manager.get_session(room_id)
        if not session:
            await sio.emit('error', {
                'message': 'Session not found'
            }, room=sid)
            return
        
        source_lang = session['customer_language']
        
        try:
            # 1. í•œêµ­ì–´ë¡œ ë²ˆì—­
            translated = await translation_service.translate(
                text=message,
                source_lang=source_lang,
                target_lang='ko',
                context='medical'
            )
            
            # 2. DBì— ì €ì¥
            await save_message(
                room_id=room_id,
                sender_type='customer',
                original_text=message,
                translated_text=translated,
                source_lang=source_lang,
                target_lang='ko'
            )
            
            # 3. ìƒë‹´ì‚¬ì—ê²Œ ì „ì†¡ (ì›ë¬¸ + ë²ˆì—­)
            agent_sid = session.get('agent_sid')
            if agent_sid:
                await sio.emit('agent_receive_message', {
                    'message_id': f"msg_{data['timestamp']}",
                    'original': message,
                    'translated': translated,
                    'source_lang': source_lang,
                    'timestamp': data['timestamp']
                }, room=agent_sid)
            
            # 4. ê³ ê°ì—ê²Œ ë°œì‹  í™•ì¸
            await sio.emit('message_sent', {
                'message_id': f"msg_{data['timestamp']}",
                'message': message,
                'timestamp': data['timestamp']
            }, room=sid)
            
        except Exception as e:
            logger.error(f"Translation error: {str(e)}")
            await sio.emit('error', {
                'message': 'Translation failed',
                'detail': str(e)
            }, room=sid)
    
    @sio.on('agent_message')
    async def handle_agent_message(sid, data):
        """
        ìƒë‹´ì‚¬ ë©”ì‹œì§€ ì²˜ë¦¬
        data = {
            'room_id': 'room_123',
            'message': 'ì•ˆë…•í•˜ì„¸ìš”, ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?',
            'timestamp': '2025-10-24T...'
        }
        """
        room_id = data['room_id']
        message = data['message']
        
        # ì„¸ì…˜ ì •ë³´
        session = await session_manager.get_session(room_id)
        if not session:
            return
        
        target_lang = session['customer_language']
        
        try:
            # 1. ê³ ê° ì–¸ì–´ë¡œ ë²ˆì—­
            translated = await translation_service.translate(
                text=message,
                source_lang='ko',
                target_lang=target_lang,
                context='medical'
            )
            
            # 2. DB ì €ì¥
            await save_message(
                room_id=room_id,
                sender_type='agent',
                original_text=message,
                translated_text=translated,
                source_lang='ko',
                target_lang=target_lang
            )
            
            # 3. ê³ ê°ì—ê²Œ ì „ì†¡ (ë²ˆì—­ëœ ë©”ì‹œì§€ë§Œ)
            customer_sid = session.get('customer_sid')
            if customer_sid:
                await sio.emit('customer_receive_message', {
                    'message_id': f"msg_{data['timestamp']}",
                    'message': translated,
                    'timestamp': data['timestamp']
                }, room=customer_sid)
            
            # 4. ìƒë‹´ì‚¬ì—ê²Œ ë°œì‹  í™•ì¸ (ì›ë¬¸ + ë²ˆì—­ ë¯¸ë¦¬ë³´ê¸°)
            await sio.emit('message_sent', {
                'message_id': f"msg_{data['timestamp']}",
                'original': message,
                'translated': translated,
                'target_lang': target_lang,
                'timestamp': data['timestamp']
            }, room=sid)
            
        except Exception as e:
            logger.error(f"Translation error: {str(e)}")
            await sio.emit('error', {
                'message': 'Translation failed'
            }, room=sid)
    
    @sio.on('typing')
    async def handle_typing(sid, data):
        """íƒ€ì´í•‘ í‘œì‹œ"""
        room_id = data['room_id']
        user_type = data['user_type']
        
        session = await session_manager.get_session(room_id)
        
        # ìƒëŒ€ë°©ì—ê²Œë§Œ ì „ì†¡
        if user_type == 'customer':
            agent_sid = session.get('agent_sid')
            if agent_sid:
                await sio.emit('user_typing', {
                    'user_type': 'customer'
                }, room=agent_sid)
        else:
            customer_sid = session.get('customer_sid')
            if customer_sid:
                await sio.emit('user_typing', {
                    'user_type': 'agent'
                }, room=customer_sid)
    
    @sio.on('stop_typing')
    async def handle_stop_typing(sid, data):
        """íƒ€ì´í•‘ ì¤‘ì§€"""
        room_id = data['room_id']
        user_type = data['user_type']
        
        session = await session_manager.get_session(room_id)
        
        if user_type == 'customer':
            agent_sid = session.get('agent_sid')
            if agent_sid:
                await sio.emit('user_stop_typing', {}, room=agent_sid)
        else:
            customer_sid = session.get('customer_sid')
            if customer_sid:
                await sio.emit('user_stop_typing', {}, room=customer_sid)
    
    @sio.on('end_chat')
    async def handle_end_chat(sid, data):
        """ì±„íŒ… ì¢…ë£Œ"""
        room_id = data['room_id']
        
        # ì„¸ì…˜ ì¢…ë£Œ ì²˜ë¦¬
        await session_manager.end_session(room_id)
        
        # ë£¸ì˜ ëª¨ë“  ì°¸ê°€ìì—ê²Œ ì•Œë¦¼
        await sio.emit('chat_ended', {
            'room_id': room_id,
            'ended_by': data.get('ended_by', 'user')
        }, room=room_id)
        
        # ë£¸ ì •ë¦¬
        await sio.leave_room(sid, room_id)
```

### C. ë²ˆì—­ ì„œë¹„ìŠ¤

```python
# backend/app/services/translation.py
from anthropic import AsyncAnthropic
from typing import Optional
import hashlib
import json
from app.services.cache import cache_service
from app.config import settings
import logging

logger = logging.getLogger(__name__)

class TranslationService:
    def __init__(self):
        self.claude = AsyncAnthropic(api_key=settings.ANTHROPIC_API_KEY)
        self.medical_glossary = self._load_glossary()
    
    def _load_glossary(self):
        """ì˜ë£Œ ìš©ì–´ì§‘ ë¡œë“œ"""
        return {
            "ko": {
                "ì˜ˆì•½": {"en": "appointment", "vi": "lá»‹ch háº¹n", "ja": "äºˆç´„", "zh": "é¢„çº¦", "th": "à¸à¸²à¸£à¸™à¸±à¸”à¸«à¸¡à¸²à¸¢"},
                "ì§„ë£Œ": {"en": "consultation", "vi": "khÃ¡m bá»‡nh", "ja": "è¨ºå¯Ÿ", "zh": "å°±è¯Š", "th": "à¸à¸²à¸£à¸•à¸£à¸§à¸ˆà¸£à¸±à¸à¸©à¸²"},
                "ì²˜ë°©ì „": {"en": "prescription", "vi": "Ä‘Æ¡n thuá»‘c", "ja": "å‡¦æ–¹ç®‹", "zh": "å¤„æ–¹", "th": "à¹ƒà¸šà¸ªà¸±à¹ˆà¸‡à¸¢à¸²"},
                "ì¦ìƒ": {"en": "symptom", "vi": "triá»‡u chá»©ng", "ja": "ç—‡çŠ¶", "zh": "ç—‡çŠ¶", "th": "à¸­à¸²à¸à¸²à¸£"},
                # ... ë” ë§ì€ ìš©ì–´
            }
        }
    
    async def translate(
        self,
        text: str,
        source_lang: str,
        target_lang: str,
        context: str = 'medical'
    ) -> str:
        """
        AI ë²ˆì—­ (ìºì‹± í¬í•¨)
        """
        # 1. ìºì‹œ í™•ì¸
        cache_key = self._get_cache_key(text, source_lang, target_lang)
        cached = await cache_service.get(cache_key)
        if cached:
            logger.info(f"Cache hit for: {text[:30]}...")
            return cached
        
        # 2. AI ë²ˆì—­
        try:
            translated = await self._translate_with_claude(
                text, source_lang, target_lang, context
            )
            
            # 3. ìºì‹œ ì €ì¥ (30ì¼)
            await cache_service.set(cache_key, translated, expire=2592000)
            
            return translated
            
        except Exception as e:
            logger.error(f"Translation failed: {str(e)}")
            raise
    
    async def _translate_with_claude(
        self,
        text: str,
        source_lang: str,
        target_lang: str,
        context: str
    ) -> str:
        """Claude APIë¡œ ë²ˆì—­"""
        
        # ìš©ì–´ì§‘ ì»¨í…ìŠ¤íŠ¸ ìƒì„±
        glossary_context = self._create_glossary_context(source_lang, target_lang)
        
        # ì–¸ì–´ë³„ ì´ë¦„ ë§¤í•‘
        lang_names = {
            'ko': 'í•œêµ­ì–´',
            'en': 'English',
            'ja': 'æ—¥æœ¬èª',
            'zh': 'ä¸­æ–‡',
            'vi': 'Tiáº¿ng Viá»‡t',
            'th': 'à¸ à¸²à¸©à¸²à¹„à¸—à¸¢'
        }
        
        prompt = f"""ë‹¹ì‹ ì€ ì˜ë£Œ ì „ë¬¸ í†µì—­ì‚¬ì…ë‹ˆë‹¤.
ë‹¤ìŒ ì˜ë£Œ ìƒë‹´ ë©”ì‹œì§€ë¥¼ {lang_names.get(target_lang, target_lang)}ë¡œ ì •í™•í•˜ê²Œ ë²ˆì—­í•´ì£¼ì„¸ìš”.

ì›ë¬¸ ì–¸ì–´: {lang_names.get(source_lang, source_lang)}
ì›ë¬¸: {text}

ì˜ë£Œ ìš©ì–´ ì°¸ê³ :
{glossary_context}

ë²ˆì—­ ì‹œ ì£¼ì˜ì‚¬í•­:
1. ì˜ë£Œ ìš©ì–´ëŠ” ì •í™•í•˜ê²Œ ë²ˆì—­
2. í™˜ì/ì˜ë£Œì§„ì˜ ì˜ë„ì™€ ê°ì •ì„ ì •í™•íˆ ì „ë‹¬
3. ê²©ì‹ìˆê³  ê³µì†í•œ í‘œí˜„ ì‚¬ìš©
4. ì¦ìƒì´ë‚˜ í†µì¦ í‘œí˜„ì€ ëª…í™•í•˜ê²Œ ë²ˆì—­
5. ë¬¸í™”ì  ì°¨ì´ë¥¼ ê³ ë ¤í•œ ìì—°ìŠ¤ëŸ¬ìš´ í‘œí˜„

ë²ˆì—­ë¬¸ë§Œ ì¶œë ¥í•˜ì„¸ìš”. ì„¤ëª…ì´ë‚˜ ì£¼ì„ ì—†ì´ ë²ˆì—­ ê²°ê³¼ë§Œ ì œê³µí•˜ì„¸ìš”."""

        message = await self.claude.messages.create(
            model="claude-sonnet-4-5-20250929",
            max_tokens=1024,
            messages=[{
                "role": "user",
                "content": prompt
            }]
        )
        
        return message.content[0].text.strip()
    
    def _create_glossary_context(self, source_lang: str, target_lang: str) -> str:
        """ìš©ì–´ì§‘ ì»¨í…ìŠ¤íŠ¸ ìƒì„±"""
        if source_lang not in self.medical_glossary:
            return ""
        
        context_lines = []
        for ko_term, translations in list(self.medical_glossary[source_lang].items())[:20]:
            if target_lang in translations:
                target_term = translations[target_lang]
                context_lines.append(f"- {ko_term} â†’ {target_term}")
        
        return "\n".join(context_lines)
    
    def _get_cache_key(self, text: str, source_lang: str, target_lang: str) -> str:
        """ìºì‹œ í‚¤ ìƒì„±"""
        content = f"{text}:{source_lang}:{target_lang}"
        hash_key = hashlib.md5(content.encode()).hexdigest()
        return f"trans:{hash_key}"

# ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
translation_service = TranslationService()
```

### D. ì„¸ì…˜ ê´€ë¦¬

```python
# backend/app/services/session.py
from typing import Dict, Optional
import asyncio
from datetime import datetime

class SessionManager:
    def __init__(self):
        # í™œì„± ì„¸ì…˜ ì €ì¥
        # room_id -> session_data
        self.sessions: Dict[str, dict] = {}
        # sid -> room_id ë§¤í•‘
        self.sid_to_room: Dict[str, str] = {}
    
    async def add_connection(
        self,
        room_id: str,
        sid: str,
        user_type: str,
        language: Optional[str] = None,
        agent_id: Optional[str] = None
    ):
        """ì—°ê²° ì¶”ê°€"""
        if room_id not in self.sessions:
            self.sessions[room_id] = {
                'customer_sid': None,
                'agent_sid': None,
                'customer_language': None,
                'agent_id': None,
                'created_at': datetime.now().isoformat(),
                'status': 'waiting'
            }
        
        session = self.sessions[room_id]
        
        if user_type == 'customer':
            session['customer_sid'] = sid
            session['customer_language'] = language
        else:  # agent
            session['agent_sid'] = sid
            session['agent_id'] = agent_id
            session['status'] = 'active'
        
        self.sid_to_room[sid] = room_id
    
    async def remove_connection(self, sid: str):
        """ì—°ê²° ì œê±°"""
        if sid in self.sid_to_room:
            room_id = self.sid_to_room[sid]
            if room_id in self.sessions:
                session = self.sessions[room_id]
                if session['customer_sid'] == sid:
                    session['customer_sid'] = None
                elif session['agent_sid'] == sid:
                    session['agent_sid'] = None
                    session['status'] = 'waiting'
            
            del self.sid_to_room[sid]
    
    async def get_session(self, room_id: str) -> Optional[dict]:
        """ì„¸ì…˜ ì •ë³´ ê°€ì ¸ì˜¤ê¸°"""
        return self.sessions.get(room_id)
    
    async def end_session(self, room_id: str):
        """ì„¸ì…˜ ì¢…ë£Œ"""
        if room_id in self.sessions:
            session = self.sessions[room_id]
            # sid_to_room ì •ë¦¬
            if session['customer_sid']:
                self.sid_to_room.pop(session['customer_sid'], None)
            if session['agent_sid']:
                self.sid_to_room.pop(session['agent_sid'], None)
            
            # ì„¸ì…˜ ì‚­ì œ
            del self.sessions[room_id]
    
    async def get_waiting_rooms(self) -> list:
        """ëŒ€ê¸° ì¤‘ì¸ ì±„íŒ…ë°© ëª©ë¡"""
        waiting = []
        for room_id, session in self.sessions.items():
            if session['status'] == 'waiting' and session['customer_sid']:
                waiting.append({
                    'room_id': room_id,
                    'customer_language': session['customer_language'],
                    'created_at': session['created_at']
                })
        return waiting

# ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
session_manager = SessionManager()
```

---

## 4. í”„ë¡ íŠ¸ì—”ë“œ (Next.js) êµ¬í˜„

### A. Socket.io í´ë¼ì´ì–¸íŠ¸ í›…

```typescript
// frontend/hooks/useSocket.ts
import { useEffect, useState, useRef } from 'react';
import { io, Socket } from 'socket.io-client';

const SOCKET_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';

export function useSocket() {
  const [isConnected, setIsConnected] = useState(false);
  const socketRef = useRef<Socket | null>(null);

  useEffect(() => {
    const socket = io(SOCKET_URL, {
      transports: ['websocket'],
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionAttempts: 5,
    });

    socket.on('connect', () => {
      console.log('Socket connected:', socket.id);
      setIsConnected(true);
    });

    socket.on('disconnect', () => {
      console.log('Socket disconnected');
      setIsConnected(false);
    });

    socket.on('error', (error) => {
      console.error('Socket error:', error);
    });

    socketRef.current = socket;

    return () => {
      socket.disconnect();
    };
  }, []);

  return {
    socket: socketRef.current,
    isConnected,
  };
}
```

### B. ì±„íŒ… í›…

```typescript
// frontend/hooks/useChat.ts
import { useState, useEffect, useCallback } from 'react';
import { Socket } from 'socket.io-client';

export interface Message {
  id: string;
  type: 'sent' | 'received';
  text: string;
  original?: string;
  translated?: string;
  timestamp: string;
  sourceLang?: string;
}

interface UseChatProps {
  socket: Socket | null;
  roomId: string;
  userType: 'customer' | 'agent';
  language?: string;
}

export function useChat({ socket, roomId, userType, language }: UseChatProps) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [isTyping, setIsTyping] = useState(false);
  const [isOnline, setIsOnline] = useState(false);

  useEffect(() => {
    if (!socket) return;

    // ë°© ì…ì¥
    socket.emit('join_room', {
      room_id: roomId,
      user_type: userType,
      customer_language: language,
    });

    // ì…ì¥ í™•ì¸
    socket.on('joined_room', (data) => {
      console.log('Joined room:', data);
    });

    // ë©”ì‹œì§€ ìˆ˜ì‹ 
    if (userType === 'customer') {
      socket.on('customer_receive_message', (data) => {
        setMessages(prev => [...prev, {
          id: data.message_id,
          type: 'received',
          text: data.message,
          timestamp: data.timestamp,
        }]);
      });

      socket.on('message_sent', (data) => {
        setMessages(prev => [...prev, {
          id: data.message_id,
          type: 'sent',
          text: data.message,
          timestamp: data.timestamp,
        }]);
      });

      socket.on('agent_online', () => {
        setIsOnline(true);
      });
    } else {
      // agent
      socket.on('agent_receive_message', (data) => {
        setMessages(prev => [...prev, {
          id: data.message_id,
          type: 'received',
          original: data.original,
          translated: data.translated,
          text: data.translated,
          sourceLang: data.source_lang,
          timestamp: data.timestamp,
        }]);
      });

      socket.on('message_sent', (data) => {
        setMessages(prev => [...prev, {
          id: data.message_id,
          type: 'sent',
          text: data.original,
          translated: data.translated,
          timestamp: data.timestamp,
        }]);
      });

      socket.on('customer_online', (data) => {
        setIsOnline(true);
      });
    }

    // íƒ€ì´í•‘ í‘œì‹œ
    socket.on('user_typing', () => {
      setIsTyping(true);
    });

    socket.on('user_stop_typing', () => {
      setIsTyping(false);
    });

    // ì±„íŒ… ì¢…ë£Œ
    socket.on('chat_ended', () => {
      console.log('Chat ended');
    });

    return () => {
      socket.off('joined_room');
      socket.off('customer_receive_message');
      socket.off('agent_receive_message');
      socket.off('message_sent');
      socket.off('user_typing');
      socket.off('user_stop_typing');
      socket.off('chat_ended');
    };
  }, [socket, roomId, userType, language]);

  const sendMessage = useCallback((message: string) => {
    if (!socket || !message.trim()) return;

    const event = userType === 'customer' ? 'customer_message' : 'agent_message';
    
    socket.emit(event, {
      room_id: roomId,
      message: message,
      timestamp: new Date().toISOString(),
    });
  }, [socket, roomId, userType]);

  const sendTyping = useCallback(() => {
    if (!socket) return;
    socket.emit('typing', {
      room_id: roomId,
      user_type: userType,
    });
  }, [socket, roomId, userType]);

  const sendStopTyping = useCallback(() => {
    if (!socket) return;
    socket.emit('stop_typing', {
      room_id: roomId,
      user_type: userType,
    });
  }, [socket, roomId, userType]);

  const endChat = useCallback(() => {
    if (!socket) return;
    socket.emit('end_chat', {
      room_id: roomId,
      ended_by: userType,
    });
  }, [socket, roomId, userType]);

  return {
    messages,
    isTyping,
    isOnline,
    sendMessage,
    sendTyping,
    sendStopTyping,
    endChat,
  };
}
```

### C. ê³ ê°ìš© ì±„íŒ… ì»´í¬ë„ŒíŠ¸

```typescript
// frontend/app/chat/[roomId]/page.tsx
'use client';

import { useState, useRef, useEffect } from 'react';
import { useSocket } from '@/hooks/useSocket';
import { useChat } from '@/hooks/useChat';

export default function ChatPage({ params }: { params: { roomId: string } }) {
  const { socket, isConnected } = useSocket();
  const [inputText, setInputText] = useState('');
  const [language, setLanguage] = useState('vi');
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const {
    messages,
    isTyping,
    isOnline,
    sendMessage,
    sendTyping,
    sendStopTyping,
  } = useChat({
    socket,
    roomId: params.roomId,
    userType: 'customer',
    language,
  });

  // ìë™ ìŠ¤í¬ë¡¤
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const handleSend = () => {
    if (!inputText.trim()) return;
    sendMessage(inputText);
    setInputText('');
    sendStopTyping();
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setInputText(e.target.value);
    sendTyping();
  };

  return (
    <div className="flex flex-col h-screen bg-gray-50">
      {/* í—¤ë” */}
      <div className="bg-blue-600 text-white p-4 flex items-center justify-between">
        <div className="flex items-center gap-3">
          <div className={`w-3 h-3 rounded-full ${isOnline ? 'bg-green-400' : 'bg-gray-400'}`} />
          <h1 className="text-lg font-semibold">ì˜ë£Œ ìƒë‹´</h1>
        </div>
        <div className={`text-sm ${isConnected ? 'text-green-200' : 'text-red-200'}`}>
          {isConnected ? 'ì—°ê²°ë¨' : 'ì—°ê²° ì¤‘...'}
        </div>
      </div>

      {/* ì–¸ì–´ ì„ íƒ */}
      <div className="p-3 bg-white border-b">
        <select
          value={language}
          onChange={(e) => setLanguage(e.target.value)}
          className="w-full p-2 border rounded-lg"
        >
          <option value="en">English</option>
          <option value="ja">æ—¥æœ¬èª</option>
          <option value="zh">ä¸­æ–‡</option>
          <option value="th">à¸ à¸²à¸©à¸²à¹„à¸—à¸¢</option>
          <option value="vi">Tiáº¿ng Viá»‡t</option>
        </select>
      </div>

      {/* ë©”ì‹œì§€ ì˜ì—­ */}
      <div className="flex-1 overflow-y-auto p-4 space-y-3">
        {messages.map((msg) => (
          <div
            key={msg.id}
            className={`flex ${msg.type === 'sent' ? 'justify-end' : 'justify-start'}`}
          >
            <div
              className={`max-w-[70%] rounded-lg p-3 ${
                msg.type === 'sent'
                  ? 'bg-blue-600 text-white'
                  : 'bg-white border border-gray-200'
              }`}
            >
              <p className="text-sm">{msg.text}</p>
              <span className="text-xs opacity-70 mt-1 block">
                {new Date(msg.timestamp).toLocaleTimeString()}
              </span>
            </div>
          </div>
        ))}

        {isTyping && (
          <div className="flex justify-start">
            <div className="bg-gray-200 rounded-lg p-3">
              <div className="flex gap-1">
                <div className="w-2 h-2 bg-gray-500 rounded-full animate-bounce" />
                <div className="w-2 h-2 bg-gray-500 rounded-full animate-bounce delay-100" />
                <div className="w-2 h-2 bg-gray-500 rounded-full animate-bounce delay-200" />
              </div>
            </div>
          </div>
        )}

        <div ref={messagesEndRef} />
      </div>

      {/* ì…ë ¥ ì˜ì—­ */}
      <div className="p-4 bg-white border-t">
        <div className="flex gap-2">
          <input
            type="text"
            value={inputText}
            onChange={handleInputChange}
            onKeyPress={(e) => e.key === 'Enter' && handleSend()}
            placeholder="ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
            className="flex-1 p-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
          <button
            onClick={handleSend}
            disabled={!inputText.trim() || !isConnected}
            className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed"
          >
            ì „ì†¡
          </button>
        </div>
      </div>
    </div>
  );
}
```

---

## 5. ë°°í¬ ë° ì¸í”„ë¼

### docker-compose.yml

```yaml
version: '3.8'

services:
  # FastAPI ë°±ì—”ë“œ
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/medtranslate
      - REDIS_URL=redis://redis:6379
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
    depends_on:
      - db
      - redis
    volumes:
      - ./backend:/app
    command: uvicorn app.main:socket_app --host 0.0.0.0 --port 8000 --reload

  # Next.js í”„ë¡ íŠ¸ì—”ë“œ (ê³ ê°ìš©)
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    environment:
      - NEXT_PUBLIC_API_URL=http://localhost:8000
    volumes:
      - ./frontend:/app
      - /app/node_modules
    command: npm run dev

  # PostgreSQL
  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: medtranslate
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  # Redis
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

---

## 6. ê°œë°œ ì¼ì • (10ì£¼)

```
Week 1-2: ë°±ì—”ë“œ ê¸°ë°˜ êµ¬ì¶•
  - FastAPI í”„ë¡œì íŠ¸ ì…‹ì—…
  - Socket.io ì„œë²„ êµ¬í˜„
  - ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì„¤ê³„
  - ê¸°ë³¸ API ì—”ë“œí¬ì¸íŠ¸

Week 3-4: ë²ˆì—­ ì—”ì§„ í†µí•©
  - Claude API í†µí•©
  - ë²ˆì—­ ì„œë¹„ìŠ¤ êµ¬í˜„
  - ìºì‹± ì‹œìŠ¤í…œ (Redis)
  - ì˜ë£Œ ìš©ì–´ì§‘ êµ¬ì¶• (1000ê°œ)

Week 5-6: í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ
  - Next.js í”„ë¡œì íŠ¸ ì…‹ì—…
  - ê³ ê°ìš© ì±„íŒ… UI
  - Socket.io í´ë¼ì´ì–¸íŠ¸ í†µí•©
  - ë°˜ì‘í˜• ë””ìì¸

Week 7-8: ìƒë‹´ì‚¬ ì½˜ì†”
  - ìƒë‹´ì‚¬ ëŒ€ì‹œë³´ë“œ
  - ë©€í‹°ì±„íŒ… ê´€ë¦¬
  - ë²ˆì—­ ë¯¸ë¦¬ë³´ê¸° UI
  - ë¹ ë¥¸ ë‹µë³€ í…œí”Œë¦¿

Week 9: í†µí•© í…ŒìŠ¤íŠ¸
  - ë¶€í•˜ í…ŒìŠ¤íŠ¸
  - ë²ˆì—­ í’ˆì§ˆ í…ŒìŠ¤íŠ¸
  - ì‹¤ì œ ìƒë‹´ì‚¬ íŒŒì¼ëŸ¿

Week 10: ë°°í¬ ë° ìµœì í™”
  - í”„ë¡œë•ì…˜ ë°°í¬
  - ëª¨ë‹ˆí„°ë§ ì„¤ì •
  - ë¬¸ì„œ ì‘ì„±
```

---

## 7. ìµœì¢… ë¹„ìš© ê²¬ì 

### ê°œë°œ ë¹„ìš©
- **ë°±ì—”ë“œ ê°œë°œ**: â‚©20,000,000
- **í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ**: â‚©18,000,000
- **AI í†µí•©**: â‚©10,000,000
- **QA/í…ŒìŠ¤íŠ¸**: â‚©7,000,000
- **ì´ ê°œë°œ ë¹„ìš©**: **â‚©55,000,000**

### ì›” ìš´ì˜ ë¹„ìš© (ë™ì‹œ 50ëª… ê¸°ì¤€)
- AWS EC2 (Backend): â‚©400,000
- RDS PostgreSQL: â‚©300,000
- Redis: â‚©150,000
- Vercel Pro (Frontend): â‚©25,000
- Claude API: â‚©600,000
- **ì›” ì´ ë¹„ìš©**: **â‚©1,475,000**

---

ì™„ë²½í•œ ì„ íƒí•˜ì…¨ìŠµë‹ˆë‹¤! ë” ê¶ê¸ˆí•œ ì  ìˆìœ¼ì‹œë©´ ë§ì”€í•´ì£¼ì„¸ìš”! ğŸš€